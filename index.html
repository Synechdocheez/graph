<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mileage Viewer</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 30px;
    }
    #controls {
      margin-bottom: 10px;
    }
    svg {
      border: 1px solid #ccc;
    }
    .line {
      fill: none;
      stroke: steelblue;
      stroke-width: 2px;
    }
    .dot {
      fill: white;
      stroke: steelblue;
      stroke-width: 1.5px;
    }
    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 6px 8px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 0.9em;
      visibility: hidden;
    }
  </style>
</head>
<body>

  <div id="controls">
    <label for="span">Show last:</label>
    <select id="span">
      <option value="7">7 days</option>
      <option value="30">30 days</option>
      <option value="90">90 days</option>
      <option value="365">365 days</option>
    </select>
  </div>

  <div style="position: relative;">
    <svg width="800" height="400"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>

  <!-- D3.js CDN -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // --- Simulate fetching your Garmin data: array of { date: Date, miles: Number }
    function generateDummyData() {
      const data = [];
      const today = new Date();
      for (let i = 0; i < 365; i++) {
        const d = new Date(today);
        d.setDate(d.getDate() - i);
        data.push({
          date: d,
          miles: +(Math.random() * 10).toFixed(1)
        });
      }
      return data.sort((a,b) => a.date - b.date);
    }

    const rawData = generateDummyData();

    // --- Set up SVG and margins
    const svg = d3.select("svg");
    const margin = { top: 20, right: 30, bottom: 30, left: 50 };
    const width = +svg.attr("width") - margin.left - margin.right;
    const height = +svg.attr("height") - margin.top - margin.bottom;
    const g = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Scales
    const x = d3.scaleTime().range([0, width]);
    const y = d3.scaleLinear().range([height, 0]);

    // Line generator
    const line = d3.line()
      .x(d => x(d.date))
      .y(d => y(d.miles));

    // Tooltip
    const tooltip = d3.select("#tooltip");

    // Overlay for capturing mouse events
    const overlay = g.append("rect")
      .attr("width", width)
      .attr("height", height)
      .style("fill", "none")
      .style("pointer-events", "all");

    // Container for circles & focus line  
    const focus = g.append("g").style("display", "none");
    focus.append("circle")
      .attr("class", "dot")
      .attr("r", 5);

    // X & Y axes groups
    const xAxisG = g.append("g")
      .attr("transform", `translate(0,${height})`);
    const yAxisG = g.append("g");

    // bisector to find nearest date
    const bisectDate = d3.bisector(d => d.date).left;

    // Draw/update function
    function update(spanDays) {
      const cutoff = new Date();
      cutoff.setDate(cutoff.getDate() - spanDays);
      const data = rawData.filter(d => d.date >= cutoff);

      x.domain(d3.extent(data, d => d.date));
      y.domain([0, d3.max(data, d => d.miles) * 1.1]);

      // draw line
      const path = g.selectAll(".line").data([data]);
      path.enter().append("path")
          .attr("class", "line")
        .merge(path)
          .attr("d", line);
      path.exit().remove();

      // draw circles
      const dots = g.selectAll(".dot").data(data);
      dots.enter().append("circle")
          .attr("class", "dot")
          .attr("r", 4)
        .merge(dots)
          .attr("cx", d => x(d.date))
          .attr("cy", d => y(d.miles));
      dots.exit().remove();

      // update axes
      xAxisG.call(d3.axisBottom(x).ticks(spanDays / 7).tickFormat(d3.timeFormat("%b %d")));
      yAxisG.call(d3.axisLeft(y));

      // hover interaction
      overlay.on("mouseover", () => focus.style("display", null))
             .on("mouseout", () => {
               focus.style("display", "none");
               tooltip.style("visibility", "hidden");
             })
             .on("mousemove", function(event) {
               const [mx] = d3.pointer(event);
               const x0 = x.invert(mx);
               const i = bisectDate(data, x0, 1);
               const d0 = data[i - 1];
               const d1 = data[i] || d0;
               const d = (x0 - d0.date) > (d1.date - x0) ? d1 : d0;

               focus.select("circle")
                 .attr("transform", `translate(${x(d.date)},${y(d.miles)})`);

               tooltip
                 .style("visibility", "visible")
                 .style("left", (d3.pointer(event, this)[0] + margin.left + 15) + "px")
                 .style("top", (d3.pointer(event, this)[1] + margin.top + 10) + "px")
                 .html(`
                   <strong>${d3.timeFormat("%B %d, %Y")(d.date)}</strong><br/>
                   Miles: ${d.miles}
                 `);
             });
    }

    // initialize
    update(7);

    // handle span change
    d3.select("#span").on("change", function() {
      update(+this.value);
    });

  </script>
</body>
</html>
